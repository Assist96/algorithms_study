# 第二章 面试所需的基础知识
### 1 编程语言（C++）
- (1) C++ 中与类型转换相关的关键字 : static_cast 、 const_cast、reinterpret_cast、dynamic_cast
- (2) C++ 中sizeof 
> （a）如果一个类没有成员只有函数等，那么sizeof（cls）=1，不是0 ，因为如果我们之后要用到该函数，那么它必须占用一定的空间，在vs 和gcc 中该大小都是1
> (b)如果一个类只有拥有虚函数，也没有数据成员，那么sizeof(cls)=8 (64位) ，因为当类拥有虚函数是，编译器会给该类构建一个虚函数表，用以存放虚函数，同时也会给类添加一个虚指针，指向该虚函数表。这样相当于类拥有一个指针成员，sizeof（ptr） 在32位系统中为4,64为系统中为8。不论有多少个虚函数都是一样大小，因为虚函数都放在了虚函数表中，只会有一个虚指针。
- (3) C++ 复制构造函数参数必须是引用参数 ，因为如果是传值参数，那么在传值时，实参——>形参会调用复制构造杉树，这样就形成了死循环。
- (4) C++ 类构建需要注意的几点：
>   （a） 在头文件中最好家伙是那个 #ifndef  #define #endif
>   （b） 返回值和参数传递尽量使用引用，如果不需要修改该参数，则传常量引用。 `string & assign(const  string & str)`
>   （c） 类函数如果不改变成员变量尽量添加const 关键字。`int get_x_val() const {}` 带 const 与不带const 构成重载函数，这是因为，成员函数都会默认传入 this 指针，如果带了const 相当于传入的是 `const class * this`
>   （d） 构造函数尽量使用赋值序列来对成员函数赋值。initialization
>   （e） 数据尽量都在 private
- (5) C++ 中用到指针的地方需要注意，要使用 `delete[]` 来进行删除，如果指针进行赋值的时候，要特别注意是指向同一地方还是，指向不同地方。
- (6) C++中使用 new 关键字要特别注意是否有足够的空间，不能先删除，要考虑好万一没有足够的空间，而先把原有数据删除，那么程序就会报错。
- (7) 设计模式之单例模式
> 单例模式即，整个程序运行期间都只需要一个实例对象。
> 因此单例模式必须将构造函数设置为 private ，因为设为了private ，外面是接触不到这个构造函数的，因此需要在类内声明一个实例对象。而为了让外部接触到这个实例对象，因此需要声明为静态对象。
> 为了保证只有在使用的时候才会去创建这个静态对象，我们需要将这个对象定义在一个静态函数中，这样只有外部使用了个静态函数，才会创建该静态对象。并且整个生命周期都会只有一个对象实例。
> 单例模式是不能被继承的，也可以将类声明为final :`class  A final{};`
### 2 数据结构
- (1) 数组
    > 数组和指针区别又有联系，数组名字也是一个指针，指向数组第一个元素。
    `int a[]={1,2,3,4,5};`
    ` int size1=sizeof(a)//20;`
    `int *p=a;`
    `sizeof(p)//4`
    `int getSize(int a1[]){}`
    如果数组作为参数传递，数组就会退化为指针，那么sizeof(a1) 就是4 

    （a）面试题3 数组中重复的数字
    > （1） 即使题干已经给出了约定条件，但是在变成的时候还是需要加上条件检测，如题干中显示，需要加上对数字大小范围进行检测。
    > （2） 为什么这里的1-n 与 0-n-1 不一致，这个需要仔细考虑一下

    （b）面试题4 二维数组查找
    > （1） C++ 中二维数组是连续的，因此，通过加减就可以获取数组。`a[i][j]=a[i*columns+j]`
    > （2） 按规律查找，可以从数组右上角开始，这样，右上角大于目标值，就向左移动，右上角小于目标值，就像下移动。
    > （3） 二维vector 和数组类似
    >       `vector<vector<int>> nums` 
    >       `   rows=nums.size()`
    >       `columns=nums[0].size()`
- (2) 字符串
  > - C++中字符串，会在末尾增加一个'\0'作为结尾，因此字符串的长度比我们看见的要大1
  > - 为了节省内存，C++ 将常量字符串放入一个单独的内存区域每当几个指针复制给相同的常量字符串时，他们实际上会指向同一位置；如下所示， str1!=str2 ，str3==str4
  > `char str1[]="hello world";`
  > `char str2[]="hello world";`
  > `char *str3="hello world";`
  > `char *str4="hello world";`
   
  (a) 面试题5 替换空格
    > - 字符串改变大小 `str.resize(new_length)`
    > - 合并两个数组/字符串时，如果从前往后复制需要移动多次，可以考虑从后往前复制。
    > - 设置初值的时候，一般是设置 `p1=s.size()-1;`这时需要特别注意，size 为0 的情况;
- (3) 链表
    > - 链表主要需要注意 指针为空的情况。
    > - 一般链表需要注意是否带了头指针，如果带了头指针，那么头节点不需要特殊处理，但是如果没有头指针，那么就需要 对头节点做特殊处理，例如传入 `ListNode ** headNode` ,判断 `headNode==Null||*headNode==Null`。
  
  (a) 面试题 6 从尾到头打印链表
    > - 一想到尾先出，头后出，就会想到栈，因此将数据顺序存入栈中，再依次取出就会得到反向结果。
    > - 与栈类似，递归也可以达成这个效果，但是递归过多有可能会导致函数调用栈溢出。
- (4) 二叉树
    > - 二叉树时重点也是难点，需要重点关注二叉树的遍历：前序、中序、后序
  （a） 面试题7 重建二叉树
    > - 二叉树相关的题目经常需要联想到 递归与迭代，与二叉树的遍历类似，
    > - 在进行数值查找的时候，可以通过哈希表进行优化。
    > - 在对数组的子数组进行操作的时候，可以只穿需要，在原始数组上进行操作，而不需要重新构建一个新的数组。
  （b） 面试提8 二叉树的下一节点
    > - 需要考虑完全多种情况：
    >  >（1）有右节点，那么就是右节点下的最左节点
    >  >（2）没有右节点，且parent 不为null,这时候主要判断这个节点是右分支上的还是左分支上的，此时需要进行判断，`cur==parent—>right && parent！=nullptr`
